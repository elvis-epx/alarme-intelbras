#!/usr/bin/env python3

import sys, socket, time, datetime, socket

def hexprint(buf):
    return ", ".join(["%02x" % n for n in buf])

# Calcula checksum de frame longo
# Presume que "dados" contém o byte de comprimento mas não contém o byte de checksum
def checksum(dados):
    checksum = 0
    for n in dados:
        checksum ^= n
    checksum ^= 0xff
    checksum &= 0xff
    return checksum

def contact_id_encode(number, length):
    number = abs(number)
    buf = []
    for i in range(0, length):
        digit = number % 10
        number //= 10
        if not digit:
            digit = 0x0a
        buf = [digit] + buf
    return buf

HOST = "192.168.0.16"
PORT = 9009

# recebidos via event 0xb5

indice_foto = 321 # int(sys.argv[2])
indice_foto = [ indice_foto // 256, indice_foto % 256 ]
numero_fotos = [2] # [int(sys.argv[3])]

'''
(Baseado nas informações supridas por R. Santos, do suporte Intelbras)

Formato geral do protocolo:

  2      2     1   2     x        1
DST_ID SRC_ID LEN CMD PAYLOAD CHECKSUM

DST_ID: identificação do servidor (central de alarme): sempre zero
SRC_ID: identificação do cliente (agente receptor IP): a escolher

Na resposta do servidor, DST é o valor originalmente suprido pelo
cliente enquanto SRC será o valor do servidor (geralmente zero)

DST_ID e SRC_ID parece ser usado para distinguir se uma mensagem é 
para nós, o que não faz muito sentido em TCP/IP pois a conexão é
apenas entre um cliente e um servidor, mas poderia fazer sentido num
bus serial.

LEN: comprimento da mensagem, CMD em diante, menos checksum igual a (2 + x)

CMD: comando enviado pelo cliente ou resposta enviada pelo servidor

PAYLOAD: de comprimento "x" variável, conforme o comando

CHECKSUM: sobre todos os octetos anteriores, mesmo algoritmo do protocolo
Receptor IP de eventos.


Antes de requisitar fotos, deve-se autenticar.

Comando de autenticação: f0f0 
Resposta: f0f0 <1 byte>

O byte de resposta é 00 (autenticação aceita), ou um dos erros:
01: senha incorreta (mais típico)
02: versão software incorreta
03: painel de alarme chamará de volta
04: aguardando por permissão de usuário


Comando de solicitação de foto: 0880

                              2      1       1
Parâmetros de solicitação: EVENT PICTURE FRAGMENT

EVENT: número ou índice do evento com foto, que foi reportado pela central
através do evento 0xB5.

PICTURE: número da foto, começando em 0. Geralmente 0 ou 1 pois o sensor
IR faz 2 fotos por evento. (Esta informação também é reportada pelo
evento 0xB5.)

Você pode começar sempre enviando 0 (que é a primeira foto, que sempre
existe, se o evento possui fotos) e descobrir quantas fotos adicionais
existem analisando a resposta.

FRAGMENT: fragmento da imagem JPEG sendo solicitado, começando em 1.
O valor 0 é aceito porém retorna um fragmento inválido (bytes 0xff).


Parâmetros de resposta (cmd também igual a 0bb0): 

  2       1     1     1        1    x
EVENT PICTURE NPIX FRAGMENT NFRAGS DATA

EVENT, PICTURE e FRAGMENT têm o mesmo valor e significado da solicitação.

NPIX: número total de imagens do evento. Use este valor para descobrir
o número de imagens atreladas ao evento.

NFRAGS: número total de fragmentos disponíveis para a imagem EVENT:PICTURE.

DATA: número variável de bytes, contendo o fragmento de imagem solicitado.
Se FRAGMENT=0, contém enchimento (bytes 0xff) que não pertence à imagem
e deve ser ignorado.

Tanto NPIX quanto NFRAGS estão disponíveis em cada resposta, portanto a
implementação pode começar a baixar a imagem por PICTURE=0 e FRAGMENT=1
(que sempre existe) e descobrir as contagens em passant. É possível (porém
não é necessário) usar FRAGMENT=0 para descobrir a priori o número de
fragmentos.

A inexistência de um evento, foto ou fragmento é indicada por resposta
NAK (vide adiante).


Comando de desconexão: f0f1, sem payload

A central responde fechando a conexão TCP/IP, sem mandar ACK nem nenhuma
outra resposta.

Não parece ser estritamente necessário em TCP/IP, bastaria fechar a conexão,
parece ser outro fóssil de protocolo bus serial.


Resposta NAK

A resposta para qualquer comando pode ser f0fd (NAK) com um byte de erro,
que indica uma mensagem malformada ou incorreta, fora dos casos em que a
resposta "normal" consegue reportar.

Por exemplo, NAK pode reportar erro de senha incorreta, mas no comando de
autenticação f0f0 a senha incorreta é indicada numa resposta "normal" f0f0.
Por outro lado, requisitar uma foto que não existe será respondido com
NAK.

Alguns códigos de erro:
01: checksum errado
02: número de bytes incorreto
23: evento sem foto associada
24: evento índice foto inválido
25: fragmento foto inválido
fe: comando inválido
ff: erro geral (pode ser erro de checksum, etc. mas a central não
                conseguiu determinar exatamente o que está errado
                na mensagem)

Resposta ACK

A resposta f0fe é uma confirmação genérica, sem payload, a um comando.
Não parece ser utilizado no contexto de obtenção de fotos.
'''


# Autentica

dst_id = [0x00, 0x00]
src_id = [0x8f, 0xff]
length = [0x00, 0x0a]  # comprimento inclui cmd, nao inclui checksum
cmd =    [0xf0, 0xf0]
swtype = [0x02] # 0x02 software de monitoramento, 0x03 mobile app
senha = contact_id_encode(int(sys.argv[1]), 6)
swver = [0x10]  # nibble.nibble (0x10 = 1.0)
msg = dst_id + src_id + length + cmd + swtype + senha + swver
msg += [ checksum(msg) ]

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.connect((HOST, PORT))

print(">", hexprint(msg))
s.sendall(bytearray(msg))
data = s.recv(1024)
print("<", hexprint(data))

# Obtém dados da foto

dst_id = [0x00, 0x00]
src_id = [0x8f, 0xff]
length = [0x00, 0x06]
cmd =    [0x0b, 0xb0]
event_index = indice_foto
picture_index = [1]  # qual imagem sera enviada
fragment_index = [0]  # fragmento 0 = solicitar info
msg = dst_id + src_id + length + cmd + event_index + picture_index + fragment_index
msg += [ checksum(msg) ]

print()
print(">", hexprint(msg))
s.sendall(bytearray(msg))
data = s.recv(1024) # espaço dos bytes de foto estufado com 0xff
print("<", hexprint(data))
print("Indice do evento: %d" % (data[8] * 256 + data[9]))
print("Indice da imagem : %d" % (data[10]))
print("Número de imagens: %d" % (data[11]))
print("Indice do fragmento: %d" % (data[12]))
nr_fragmentos = data[13]
print("Numero de fragmentos: %d" % nr_fragmentos)
print("Bytes recebidos: %d" % (len(data) - 1 - 14))

f = open("imagem2.jpeg", "wb")

for frag in range(1, nr_fragmentos + 1):
    dst_id = [0x00, 0x00]
    src_id = [0x8f, 0xff]
    length = [0x00, 0x06]
    cmd =    [0x0b, 0xb0]
    event_index = indice_foto
    picture_index = [0]  # qual imagem sera enviada
    fragment_index = [frag]  # fragmento solicitado
    msg = dst_id + src_id + length + cmd + event_index + picture_index + fragment_index
    msg += [ checksum(msg) ]

    print()
    print(">", hexprint(msg))
    s.sendall(bytearray(msg))
    data = s.recv(1024)
    print("<", hexprint(data))
    print("Bytes recebidos: %d" % (len(data) - 1 - 14))
    if checksum(data) == 0:
        print("Checksum ok")
    else:
        print("Checksum não ok")
    f.write(data[14:-1])

f.close()

# Desconecta

dst_id = [0x00, 0x00]
src_id = [0x8f, 0xff]
length = [0x00, 0x02]
cmd =    [0xf0, 0xf1]
chksum = [checksum(dst_id + src_id + length + cmd)]
msg = dst_id + src_id + length + cmd
msg += [ checksum(msg) ]

print()
print(">", hexprint(msg))
s.sendall(bytearray(msg))
data = s.recv(1024)
print("<", hexprint(data))
