#!/usr/bin/env python3

import sys, time, datetime, random, os, shlex

from myeventloop import Timeout, Log, LOG_INFO, LOG_DEBUG
from tcpserver import *
from tcpclient import *

Log.set_level(LOG_INFO)

# Mensagens que podem ser repassadas em lote podem ser
# extraídas do log salvo em arquivo

class UtilsProtocolo:
    def hexprint(self, buf):
        return ", ".join(["%02x" % n for n in buf])

    # Calcula checksum de frame longo
    # Presume que "dados" contém o byte de comprimento mas não contém o byte de checksum
    def checksum(self, dados):
        checksum = 0
        for n in dados:
            checksum ^= n
        checksum ^= 0xff
        checksum &= 0xff
        return checksum

    # Decodifica número no formato "Contact ID"
    # Retorna -1 se aparenta estar corrompido
    def contact_id_decode(self, dados):
        dados_rev = dados[:]
        dados_rev.reverse()
        numero = 0
        posicao = 1
        for digito in dados_rev:
            if digito == 0x0a: # zero
                pass
            elif digito >= 0x01 and digito <= 0x09:
                numero += posicao * digito
            else:
                Log.warn("valor contact id invalido", self.hexprint(dados))
                return -1
            posicao *= 10
        return numero
    
    # Codifica um número de tamanho fixo no formato Contact-ID
    def contact_id_encode(self, number, length):
        number = abs(number)
        buf = []
        for i in range(0, length):
            digit = number % 10
            number //= 10
            if not digit:
                digit = 0x0a
            buf = [digit] + buf
        return buf
    
    def bcd(self, n):
        if n > 99 or n < 0:
            Log.warn("valor invalido para BCD: %02x" % n)
            return 0
        return ((n // 10) << 4) + (n % 10)
    
    def from_bcd(self, dados):
        n = 0
        dados_rev = dados[:]
        dados_rev.reverse()
        numero = 0
        posicao = 1
        for nibbles in dados_rev:
            numero += (nibbles >> 4) * 10 * posicao
            numero += (nibbles & 0x04) * posicao
            posicao *= 100
        return numero
    
    # Codifica um número de 16 bits em 2 octetos
    def be16(self, n):
        return [ n // 256, n % 256 ]
    
    # Decodifica um buffer de 2 octetos para inteiro de 16 bits
    def parse_be16(self, buf):
        return buf[0] * 256 + buf[1]
    
# Agente que obtem fotos de um evento de sensor com câmera

class ObtemFotosDeEvento(TCPClientHandler, UtilsProtocolo):
    def __init__(self, ip_addr, cport, indice, nrfoto, senha, tam_senha, observer):
        super().__init__((ip_addr, cport))
        self.log_info("Iniciando obtencao de foto %d:%d" % (indice, nrfoto))
        self.conn_timeout = self.timeout("conn_timeout", 15, self.conn_timeout)
        self.ip_addr = ip_addr
        self.cport = cport
        self.indice = indice
        self.nrfoto = nrfoto
        self.senha = senha
        self.tam_senha = tam_senha
        self.observer = observer
        self.arquivo = ""

        # Se destruído com esse status, reporta erro fatal
        self.status = 2

        self.tratador = None

    def destroyed_callback(self):
        # Informa observador sobre status final da tarefa
        self.observer.resultado_foto(self.ip_addr, self.cport, \
                                     self.indice, self.nrfoto, \
                                     self.status, self.arquivo)

    def conn_timeout(self, task):
        if self.status != 0:
            # reporta erro não-fatal, exceto se status = 0 (download completo)
            self.status = 1
        self.log_info("Timeout conexao foto")
        self.destroy()

    def connection_callback(self, ok):
        self.conn_timeout.cancel()
        if not ok:
            self.status = 1 # erro não-fatal
            self.log_info("Conexao foto falhou")
            # destroy() executado pelo chamador
            return
        self.autenticacao()

    # Cria um pacote válido do protocolo de obtenção de fotos
    def pacote_foto(self, cmd, payload):
        # ID da central, sempre zero
        dst_id = self.be16(0x0000)
        # ID nosso, pode ser qualquer número, devolvido nos pacotes de retorno
        # Possivelmente uma relíquia de canais seriais onde múltiplos receptores
        # ouvem as mensagens, e dst_id ajudaria a identificar o recipiente
        src_id = self.be16(0x8fff)
        length = self.be16(len(payload) + 2)
        cmd_enc = self.be16(cmd)
        pacote = dst_id + src_id + length + cmd_enc + payload
        pacote = pacote + [ self.checksum(pacote) ]
        return pacote

    # Cria um pacote de autenticação para o protocolo de fotos
    # No protocolo de fotos, a autenticação deve preceder o download
    def pacote_foto_auth(self, senha, tam_senha):
        # 0x02 software de monitoramento, 0x03 mobile app
        sw_type = [ 0x02 ]
        senha = self.contact_id_encode(senha, tam_senha)
        sw_ver = [ 0x10 ]  # nibble.nibble (0x10 = 1.0)
        payload = sw_type + senha + sw_ver
        return self.pacote_foto(0xf0f0, payload)

    def autenticacao(self):
        self.log_debug("Conexao foto: auth")
        pct = self.pacote_foto_auth(self.senha, self.tam_senha)
        self.send(pct)

        self.tratador = self.resposta_autenticacao
        self.conn_timeout.restart()

    def resposta_autenticacao(self, cmd, payload):
        if cmd == 0xf0fd:
            self.nak(payload)
            return

        if cmd != 0xf0f0:
            self.log_info("Conexao foto: resp inesperada %04x" % cmd)
            self.destroy()
            return

        if len(payload) != 1:
            self.log_info("Conexao foto: resp auth invalida")
            self.destroy()
            return

        resposta = payload[0]
        # Possíveis respostas:
        # 01 = senha incorreta
        # 02 = versão software incorreta
        # 03 = painel chamará de volta (?)
        # 04 = aguardando permissão de usuário (?)
        if resposta > 0:
            self.log_info("Conexao foto: auth falhou motivo %d" % resposta)
            self.destroy()
            return

        self.log_info("Conexao foto: autenticado")
        self.inicia_obtencao_fotos()

    def inicia_obtencao_fotos(self):
        # Fragmento 1 sempre existe
        self.obtem_fragmento_foto(1, [])

    # Cria um pacote de requisição de fragmento de foto
    def pacote_foto_req(self, indice, foto, fragmento):
        payload = self.be16(indice) + [ foto, fragmento ]
        return self.pacote_foto(0x0bb0, payload)

    def obtem_fragmento_foto(self, fragmento_corrente, jpeg_corrente):
        self.log_debug("Conexao foto: obtendo fragmento %d" % fragmento_corrente)
        pct = self.pacote_foto_req(self.indice, self.nrfoto, fragmento_corrente)
        self.send(pct)

        def tratador(cmd, payload):
            self.resposta_fragmento(cmd, payload, fragmento_corrente, jpeg_corrente)

        self.tratador = tratador
        self.conn_timeout.restart()

    def resposta_fragmento(self, cmd, payload, fragmento_corrente, jpeg_corrente):
        if cmd == 0xf0fd:
            self.nak(payload)
            return

        if cmd == 0xf0f7:
            # Código não documentado retornado pela central após lentidão
            # Possivelmente sinaliza central ocupada
            self.status = 1 # erro não-fatal
            self.destroy()
            return

        if cmd != 0x0bb0:
            self.log_info("Conexao foto: resp inesperada %04x" % cmd)
            self.destroy()
            return

        if len(payload) < 6:
            self.log_info("Conexao foto: resp frag muito curta")
            self.destroy()
            return

        self.log_debug("Conexao foto: resposta fragmento %d" % fragmento_corrente)

        indice = self.parse_be16(payload[0:2])
        foto = payload[2]
        nr_fotos = payload[3]
        fragmento = payload[4]
        nr_fragmentos = payload[5]
        fragmento_jpeg = payload[6:]

        if indice != self.indice:
            self.log_info("Conexao foto: indice invalido")
            self.destroy()
            return

        if foto != self.nrfoto:
            self.log_info("Conexao foto: nr foto invalida")
            self.destroy()
            return

        if fragmento != fragmento_corrente:
            self.log_info("Conexao foto: frag corrente invalido")
            self.destroy()
            return

        jpeg_corrente += fragmento_jpeg

        if fragmento < nr_fragmentos:
            self.obtem_fragmento_foto(fragmento + 1, jpeg_corrente)
            return

        self.log_info("Conexao foto: salvando imagem")
        self.arquivo = "imagem%.6f.jpeg" % time.time()
        f = open(self.arquivo, "wb")
        f.write(bytearray(jpeg_corrente))
        f.close()

        self.despedida()

    # Cria um pacote de desconexão
    def pacote_foto_bye(self):
        return self.pacote_foto(0xf0f1, [])

    def despedida(self):
        self.log_debug("Conexao foto: despedindo")
        pct = self.pacote_foto_bye()
        self.send(pct)

        self.tratador = None
        # Reportar sucesso ao observador
        self.status = 0
        self.conn_timeout.restart()
        # Resposta esperada: central fechar conexão

    def nak(self, payload):
        if len(payload) != 1:
            self.log_info("Conexao foto: NAK invalido")
        else:
            # NAK comum = 0x28 significando que foto ainda não foi transferida do sensor
            # Por isso consideramos NAK um erro não-fatal, poderia refinar por motivo
            motivo = payload[0]
            self.log_info("Conexao foto: NAK motivo %02x" % motivo)
            self.status = 1 # erro não-fatal
        self.destroy()

    # Motivos NAK (nem todos se aplicam a download de fotos):
    # 00    Mensagem Ok (Por que NAK então? ACK = cmd 0xf0fe)
    # 01    Erro de checksum (daqui para baixo, todos são erros)
    # 02    Número de bytes da mensagem
    # 03    Número de bytes do parâmetro (payload)
    # 04    Parâmetro inexistente
    # 05    Indice parâmetro
    # 06    Valor máximo
    # 07    Valor mínimo
    # 08    Quantidade de campos
    # 09    Nibble 0-9
    # 0a    Nibble 1-a
    # 0b    Nibble 0-f
    # 0c    Nibble 1-f-ex-b-c
    # 0d    ASCII
    # 0e    29 de fevereiro
    # 0f    Dia inválido
    # 10    Mês inválido
    # 11    Ano inválido
    # 12    Hora inválida
    # 13    Minuto inválido
    # 14    Segundo inválido
    # 15    Tipo de comando inválido
    # 16    Tecla especial
    # 17    Número de dígitos
    # 18    Número de dígitos senha
    # 19    Senha incorreta (mas reportado na resposta da autenticação, não por NAK)
    # 1a    Partição inexistente
    # 1b    Usuário sem permissão na partição
    # 1c    Sem permissão programar
    # 1d    Buffer de recepção cheio
    # 1e    Sem permissão para desarmar
    # 1f    Necessária autenticação prévia
    # 20    Sem zonas habilitadas
    # 21    Sem permissão para comando
    # 22    Sem partições definidas
    # 23    Evento sem foto associada
    # 24    Índice foto inválido
    # 25    Fragmento foto inválido
    # 26    Sistema não particionado
    # 27    Zonas abertas
    # 28    Ainda gravando foto / transferindo do sensor (tente mais tarde)
    # 29    Acesso mobile desabilitado
    # 2a    Operação não permitida
    # 2b    Memória RF vazia
    # 2c    Memória RF ocupada
    # 2d    Senha repetida
    # 2e    Falha ativação/desativação
    # 2f    Sem permissão arme stay
    # 30    Desative a central
    # 31    Reset bloqueado
    # 32    Teclado bloqueado
    # 33    Recebimento de foto falhou
    # 34    Não conectado ao servidor
    # 35    Taclado sem permissão
    # 36    Partição sem zonas stay
    # 37    Sem permissão bypass
    # 38    Firmware corrompido
    # fe    Comando inválido
    # ff    Erro não especificado (não documentado mas observado se checksum ou tamanho pacote errado)

    # Retorna o comprimento de um pacote, se houver um pacote completo no buffer
    # Se não, retorna 0
    def pacote_foto_completo(self, data):
        # Um pacote tem tamanho mínimo 9 (src_id, dst_id, len, cmd, checksum)
        if len(data) < 9:
            return 0
        compr = 6 + self.parse_be16(data[4:6]) + 1
        if len(data) < compr:
            return 0
        return compr

    # Consiste um pacote do protocolo de foto
    def pacote_foto_correto(self, pct):
        compr_liquido = self.parse_be16(pct[4:6])
        if compr_liquido < 2:
            # Um pacote deveria ter no minimo um comando
            return False
        # Algoritmo de checksum tem propriedade interessante:
        # checksum de pacote sufixado com checksum resulta em 0
        return self.checksum(pct) == 0x00

    # Interpreta um pacote do protocolo de foto
    def pacote_foto_parse(self, pct):
        compr_liquido = self.parse_be16(pct[4:6])
        compr_payload = compr_liquido - 2
        cmd = self.parse_be16(pct[6:8])
        payload = pct[8:8+compr_payload]
        return cmd, payload

    def recv_callback(self, latest):
        self.log_debug("Conexao foto: recv", self.hexprint(latest))

        compr = self.pacote_foto_completo(self.recv_buf)
        if not compr:
            self.log_debug("Conexao foto: incompleto")
            return

        pct, self.recv_buf = self.recv_buf[:compr], self.recv_buf[compr:]

        if not self.pacote_foto_correto(pct):
            self.log_info("Conexao foto: pacote incorreto, desistindo")
            self.destroy()
            return

        cmd, payload = self.pacote_foto_parse(pct)
        self.log_debug("Conexao foto: resposta %04x" % cmd)

        if not self.tratador:
            self.log_info("Conexao foto: sem tratador")
            self.destroy()
            return

        self.conn_timeout.cancel()
        self.tratador(cmd, payload)


class Tratador(TCPServerHandler, UtilsProtocolo):
    backoff_minimo = 0.125
    recuo_backoff_minimo = 1.0 # Deve ser bem maior que RTT esperado

    eventos_contact_id = {
        100: {'*': "Emergencia medica"},
        110: {'*': "Alarme de incendio"},
        120: {'*': "Panico"},
        121: {'*': "Ativacao/desativacao sob coacao"},
        122: {'*': "Panico silencioso"},
        130: {
            'aber': "Disparo de zona {zona}",
            'rest': "Restauracao de zona {zona}"
             },
        133: {'*': "Disparo de zona 24h {zona}"},
        146: {'*': "Disparo silencioso {zona}"},
        301: {
            'aber': "Falta de energia AC",
            'rest': "Retorno de energia AC"
             },
        342: {
             'aber': "Falta de energia AC em componente sem fio {zona}",
             'rest': "Retorno energia AC em componente sem fio {zona}"
             },
        302: {
            'aber': "Bateria do sistema baixa",
            'rest': "Recuperacao bateria do sistema baixa"
             },
        305: {'*': "Reset do sistema"},
        306: {'*': "Alteracao programacao"},
        311: {
            'aber': "Bateria ausente",
            'rest': "Recuperacao bateria ausente"
             },
        351: {
            'aber': "Corte linha telefonica",
            'rest': "Restauro linha telefonica"
             },
        354: {'*': "Falha ao comunicar evento"},
        147: {
            'aber': "Falha de supervisao {zona}",
            'rest': "Recuperacao falha de supervisao {zona}"
             },
        145: {
             'aber': "Tamper em dispositivo expansor {zona}",
             'rest': "Restauro tamper em dispositivo expansor {zona}"
              },
        383: {
              'aber': "Tamper em sensor {zona}",
              'rest': "Restauro tamper em sensor {zona}"
              },
        384: {
            'aber': "Bateria baixa em componente sem fio {zona}",
            'rest': "Recuperacao bateria baixa em componente sem fio {zona}"
             },
        401: {
             'rest': "Ativacao manual",
             'aber': "Desativacao manual"
             },
        403: {
             'rest': "Ativacao automatica",
             'aber': "Desativacao automatica"
             },
        404: {
            'rest': "Ativacao remota",
            'aber': "Desativacao remota",
             },
        407: {
            'rest': "Ativacao remota II",
            'aber': "Desativacao remota II",
             },
        408: {'*': "Ativacao por uma tecla"},
        410: {'*': "Acesso remoto"},
        461: {'*': "Senha incorreta"},
        570: {
             'aber': "Bypass de zona {zona}",
             'rest': "Cancel bypass de zona {zona}"
             },
        602: {'*': "Teste periodico"},
        621: {'*': "Reset do buffer de eventos"},
        601: {'*': "Teste manual"},
        616: {'*': "Solicitacao de manutencao"},
        422: {
            'aber': "Acionamento de PGM {zona}",
            'rest': "Desligamento de PGM {zona}"
             },
        625: {'*': "Data e hora reiniciados"}
    }

    def __init__(self, addr, sock):
        super().__init__(addr, sock)

        self.log_info("inicio")
        self.backoff = Tratador.backoff_minimo

        self.to_ident = self.timeout("ident", 120, self.timeout_identificacao)
        self.to_comm = self.timeout("comm", 600, self.timeout_comunicacao)
        self.to_processa = None
        self.to_incompleta = None
        self.to_backoff = None

        self.ip_addr = addr[0]

    def timeout_comunicacao(self, _):
        self.log_info("timeout de comunicacao")
        self.destroy()

    def timeout_msgincompleta(self, _):
        self.log_warn("timeout de mensagem incompleta, buf =", self.hexprint(self.recv_buf))
        self.destroy()

    def timeout_identificacao(self, _):
        self.log_warn("timeout de identificacao")
        self.destroy()

    def _envia(self, resposta):
        self.send(bytearray(resposta))
        self.log_debug("enviada resposta", self.hexprint(resposta))

    def enquadrar(self, dados):
        dados = [len(dados)] + dados
        return dados + [ self.checksum(dados) ]

    def envia_longo(self, resposta):
        resposta = self.enquadrar(resposta)
        self._envia(resposta)

    def envia_curto(self, resposta):
        self._envia(resposta)

    def recv_callback(self, _):
        self.log_debug("evento")
        self.log_debug("buf =", self.hexprint(self.recv_buf))
        self.to_comm.restart()
        if not self.to_processa:
            self.to_processa = self.timeout("proc_msg", self.backoff, self.processar_msg)

    def shutdown_callback(self):
        self.log_info("fechada")
        super().shutdown_callback() # impl padrão = fechar

    def send_callback(self):
        self.log_debug("envio dados")
        super().send_callback()

    def processar_msg(self, _):
        self.to_processa = None
        msg_aceita, msgs_pendentes = self.consome_msg()
        if msg_aceita:
            self.avancar_backoff()
        if msgs_pendentes:
            self.to_processa = self.timeout("proc_msg", self.backoff, self.processar_msg)

    def consome_msg(self):
        if self.consome_frame_curto() or self.consome_frame_longo():
            # Processou uma mensagem
            if self.to_incompleta:
                self.to_incompleta.cancel()
                self.to_incompleta = None
            return True, not not self.recv_buf

        if self.recv_buf:
            # Mensagem incompleta no buffer
            if not self.to_incompleta:
                self.to_incompleta = self.timeout("msgincompleta", 60, self.timeout_msgincompleta)
        return False, False

    def avancar_backoff(self):
        self.backoff *= 2 # Backoff exponencial
        self.log_debug("backoff aumentado para %f" % self.backoff)

        if self.to_backoff:
            self.to_backoff.cancel()
            self.to_backoff = None

        self.to_backoff = self.timeout("recuar_backoff",
            max(Tratador.recuo_backoff_minimo, self.backoff * 2),
            self.recuar_backoff)

    def recuar_backoff(self, _):
        self.to_backoff = None

        self.backoff /= 2
        self.backoff = max(self.backoff, Tratador.backoff_minimo)
        self.log_debug("backoff reduzido para %f" % self.backoff)

        if self.backoff > Tratador.backoff_minimo:
            self.to_backoff = self.timeout("recuar_backoff",
                max(Tratador.recuo_backoff_minimo, self.backoff * 2),
                self.recuar_backoff)

    def consome_frame_curto(self):
        if self.recv_buf and self.recv_buf[0] == 0xf7:
            self.recv_buf = self.recv_buf[1:]
            self.log_debug("heartbeat da central")
            resposta = [0xfe]
            self.envia_curto(resposta)
            return True
        return False

    def consome_frame_longo(self):
        if len(self.recv_buf) < 2:
            return False

        esperado = self.recv_buf[0] + 2 # comprimento + dados + checksum
        if len(self.recv_buf) < esperado:
            return False

        rawmsg = self.recv_buf[:esperado]
        self.recv_buf = self.recv_buf[esperado:]

        # checksum de pacote sufixado com checksum resulta em 0
        if self.checksum(rawmsg) != 0x00:
            self.log_warn("checksum errado, rawmsg =", self.hexprint(rawmsg))
            return True

        # Mantém checksum no final pois, em algumas mensagens, o último octeto
        # calcula como checksum mas tem outro significado (e.g. 0xb5)
        msg = rawmsg[1:]

        if not msg:
            self.log_warn("mensagem nula")
            return True

        tipo = msg[0]
        msg = msg[1:]

        if tipo == 0x80:
            self.solicita_data_hora(msg)
        elif tipo == 0x94:
            self.identificacao_central(msg)
        elif tipo == 0xb0:
            self.evento_alarme(msg, False)
        elif tipo == 0xb5:
            self.evento_alarme(msg, True)
        else:
            self.log_warn("solicitacao desconhecida %02x payload =" % tipo, self.hexprint(msg))
            self.resposta_generica(msg)
        return True

    def resposta_generica(self, msg):
        resposta = [0xfe]
        self.envia_curto(resposta)

    # TODO verificar se a central é a esperada
    def identificacao_central(self, msg):
        if len(msg) != 7:
            self.log_warn("identificacao central: tamanho inesperado,", self.hexprint(msg))
        else:
            canal = msg[0] # 'E' (0x45)=Ethernet, 'G'=GPRS, 'H'=GPRS2
            conta = self.from_bcd(msg[1:3])
            macaddr = msg[3:6]
            macaddr_s = ":".join(["%02x" % i for i in macaddr])
            self.log_info("identificacao central conta %d mac %s" % (conta, macaddr_s))
            if self.to_ident:
                self.to_ident.cancel()
                self.to_ident = None

        resposta = [0xfe]
        self.envia_curto(resposta)

    def solicita_data_hora(self, msg):
        self.log_debug("solicitacao de data/hora pela central")
        agora = datetime.datetime.now()
        # proto: 0 = domingo; weekday(): 0 = segunda
        dow = (agora.weekday() + 1) % 7
        resposta = [ 0x80, self.bcd(agora.year - 2000), self.bcd(agora.month), self.bcd(agora.day), \
            self.bcd(dow), self.bcd(agora.hour), self.bcd(agora.minute), self.bcd(agora.second) ]
        self.envia_longo(resposta)

    def msg_para_gancho(self, *msg):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        msgw = now
        for item in msg:
            msgw += " "
            msgw += str(item)
        p = os.popen("./gancho_msg %s" % shlex.quote(msgw), 'w')
        p.close()

    def evento_alarme(self, msg, com_foto):
        compr = com_foto and 20 or 17
        if len(msg) != compr:
            self.log_warn("evento de alarme de tamanho inesperado,", self.hexprint(msg))
            resposta = [0xfe]
            self.envia_curto(resposta)
            return

        canal = msg[0] # 0x11 Ethernet IP1, 0x12 IP2, 0x21 GPRS IP1, 0x22 IP2
        contact_id = self.contact_id_decode(msg[1:5])
        tipo_msg = self.contact_id_decode(msg[5:7]) # 18 decimal = Contact ID
        qualificador = msg[7]
        codigo = self.contact_id_decode(msg[8:11])
        particao = self.contact_id_decode(msg[11:13])
        zona = self.contact_id_decode(msg[13:16])
        if com_foto:
            checksum = msg[16] # truque do protocolo de reposicionar o checksum
            indice = msg[17] * 256 + msg[18]
            nr_fotos = msg[19]

        desconhecido = True
        if tipo_msg == 18 and codigo in Tratador.eventos_contact_id:
            if qualificador == 1:
                squalif = "aber"
                if squalif not in Tratador.eventos_contact_id[codigo]:
                    squalif = "*"
            elif qualificador == 3:
                squalif = "rest"
                if squalif not in Tratador.eventos_contact_id[codigo]:
                    squalif = "*"
            else:
                squalif = "*"

            if squalif in Tratador.eventos_contact_id[codigo]:
                desconhecido = False
                scodigo = Tratador.eventos_contact_id[codigo][squalif]
                fotos = ""
                if com_foto:
                    fotos = "(com fotos, i=%d n=%d)" % (indice, nr_fotos)
                descricao_humana = scodigo.format(zona=zona, particao=particao)
                self.log_info(descricao_humana, fotos)
                self.msg_para_gancho(descricao_humana, fotos)

                if com_foto:
                    for n in range(0, nr_fotos):
                        Tratador.tratador_de_fotos.enfileirar(self.ip_addr, indice, n)

        if desconhecido:
            msg = "Evento de alarme canal %02x contact_id %d tipo %d qualificador %d " \
                  "codigo %d particao %d zona %d" % \
                  (canal, contact_id, tipo_msg, qualificador, codigo, particao, zona)
            self.log_info(msg)
            self.msg_para_gancho(msg)

        resposta = [0xfe]
        self.envia_curto(resposta)


# Tratador de fotos obtidas via eventos 0xb5. Desacoplado do tratador 
# principal pois usa conexões separadas, e as fotos ficam armazenadas
# por tempo indeterminado na central, não sendo atreladas à conexão com
# o Receptor IP.
#
# Numa implementação futura os índices das fotos poderiam ser até
# armazenados num banco de dados local, para que não se percam quando
# o programa é reiniciado.

class TratadorDeFotos:
    def __init__(self, cport, senha, tam_senha):
        self.cport = cport
        self.senha = senha
        self.tam_senha = tam_senha
        self.fila = [] # [endereço IP, indice, nr. foto, tentativas restantes]
        self.task = None

    # Recebe nova foto de algum Tratador para a fila
    def enfileirar(self, ip_addr, indice, nrfoto):
        if self.tam_senha <= 0:
            return
        self.fila.append([ip_addr, indice, nrfoto, 10])
        if not self.task:
            # Fotos de sensor 8000 demoram para gravar (NAK 0x28 = foto não gravada)
            self.task = Timeout.new("trata_foto", 20, self.obtem_foto)

    def obtem_foto(self, task):
        if not self.fila:
            self.task = None
            return

        ip_addr, indice, nrfoto, tentativas = self.fila[0]
        Log.info("tratador de fotos: obtendo %s:%d:%d tentativas %d" % \
                      (ip_addr, indice, nrfoto, tentativas))

        ObtemFotosDeEvento(ip_addr, self.cport, indice, nrfoto, \
                            self.senha, self.tam_senha, self)

    def msg_para_gancho_arquivo(self, arquivo):
        p = os.popen("./gancho_arquivo %s" % arquivo, 'w')
        p.close()

    # observer chamado quando ObtemFotosDeEvento finaliza
    def resultado_foto(self, ip_addr, cport, indice, nrfoto, status, arquivo):
        if status == 0:
            Log.info("Fotos indice %s:%d:%d: sucesso" % (ip_addr, indice, nrfoto))
            Log.info("Arquivo de foto %s" % arquivo)
            self.msg_para_gancho_arquivo(arquivo)
            del self.fila[0]
        elif status == 2:
            Log.info("Fotos indice %s:%d:%d: erro fatal" % (ip_addr, indice, nrfoto))
            del self.fila[0]
        else:
            self.fila[0][3] -= 1
            if self.fila[0][3] <= 0:
                Log.info("Fotos indice %s:%d:%d: tentativas esgotadas" % (ip_addr, indice, nrfoto))
                del self.fila[0]
            else:
                Log.info("Fotos indice %s:%d:%d: erro temporario" % (ip_addr, indice, nrfoto))

        self.task.restart()


def heartbeat(to_obj):
    Log.info("receptor em funcionamento")
    to_obj.reset(86400)

Timeout.new("heartbeat", 30, heartbeat)

host = "0.0.0.0"
port = int(sys.argv[1]) or 9009  # Porta deste Receptor IP
cport = int(sys.argv[2]) or 9009 # Porta da central de alarme
senha = int(sys.argv[3])         # Senha de acesso remoto (usuário 98)
tam_senha = int(sys.argv[4])     # Tamanho da senha (4 ou 6 dígitos)

Tratador.tratador_de_fotos = TratadorDeFotos(cport, senha, tam_senha)

ev = TCPServerEventLoop((host, port), TCPListener, Tratador)

def watchdog(to_obj):
    centrais_conectadas = 0
    for h in Handler.items.values():
        if isinstance(h, Tratador):
            centrais_conectadas += 1
    if not centrais_conectadas:
        Log.info("nenhuma central conectada")
    to_obj.reset(3600)

Timeout.new("watchdog", 60, watchdog)

ev.loop()
