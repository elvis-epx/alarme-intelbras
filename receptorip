#!/usr/bin/env python3

import sys, time, datetime, random

from myeventloop import Timeout, Log, LOG_INFO, LOG_DEBUG
from tcpserver import *
from tcpclient import *

Log.set_level(LOG_DEBUG)

def hexprint(buf):
    return ", ".join(["%02x" % n for n in buf])

# Calcula checksum de frame longo
# Presume que "dados" contém o byte de comprimento mas não contém o byte de checksum
def checksum(dados):
    checksum = 0
    for n in dados:
        checksum ^= n
    checksum ^= 0xff
    checksum &= 0xff
    return checksum

# Verifica checksum de frame longo
# Presume um frame completo, com checksum no último byte
def verificar(dados):
    return checksum(dados[:-1]) == dados[-1]

# Enquadra mensagem no formato quadro longo
# Adiciona comprimento no início e checksum no final
def enquadrar(dados):
    dados = [len(dados)] + dados
    return dados + [ checksum(dados) ]

# Decodifica número no formato "Contact ID"
# Retorna -1 se aparenta estar corrompido
def contact_id_decode(dados):
    dados_rev = dados[:]
    dados_rev.reverse()
    numero = 0
    posicao = 1
    for digito in dados_rev:
        if digito == 0x0a: # zero
            pass
        elif digito >= 0x01 and digito <= 0x09:
            numero += posicao * digito
        else:
            Log.warn("valor contact id invalido", hexprint(dados))
            return -1
        posicao *= 10
    return numero

# Codifica um número de tamanho fixo no formato Contact-ID
def contact_id_encode(number, length):
    number = abs(number)
    buf = []
    for i in range(0, length):
        digit = number % 10
        number //= 10
        if not digit:
            digit = 0x0a
        buf = [digit] + buf
    return buf

def bcd(n):
    if n > 99 or n < 0:
        Log.warn("valor invalido para BCD: %02x" % n)
        return 0
    return ((n // 10) << 4) + (n % 10)

def from_bcd(dados):
    n = 0
    dados_rev = dados[:]
    dados_rev.reverse()
    numero = 0
    posicao = 1
    for nibbles in dados_rev:
        numero += (nibbles >> 4) * 10 * posicao
        numero += (nibbles & 0x04) * posicao
        posicao *= 100
    return numero

# Codifica um número de 16 bits em 2 octetos
def be16(n):
    return [ n // 256, n % 256 ]

# Decodifica um buffer de 2 octetos para inteiro de 16 bits
def parse_be16(buf):
    return buf[0] * 256 + buf[1]

# Cria um pacote válido do protocolo de obtenção de fotos
def pacote_foto(cmd, payload):
    dst_id = be16(0x0000)
    src_id = be16(0x8fff)
    length = be16(len(payload) + 2)
    cmd_enc = be16(cmd)
    pacote = dst_id + src_id + length + cmd_enc + payload
    pacote = pacote + [ checksum(pacote) ]
    return pacote

# Retorna o comprimento de um pacote, se houver um pacote completo no buffer
# Se não, retorna 0
def pacote_foto_completo(data):
    # Um pacote tem tamanho mínimo 9 (src_id, dst_id, len, cmd, checksum)
    if len(data) < 9:
        return 0
    compr = 6 + parse_be16(data[4:6]) + 1
    if len(data) < compr:
        return 0
    return compr

# Consiste um pacote do protocolo de foto
def pacote_foto_correto(pct):
    compr_liquido = parse_be16(pct[4:6])
    if compr_liquido < 2:
        # Um pacote deveria ter no minimo um comando
        return False
    # Algoritmo de checksum tem propriedade interessante:
    # checksum de pacote sufixado com checksum resulta em 0
    return checksum(pct) == 0x00

# Interpreta um pacote do protocolo de foto
def pacote_foto_parse(pct):
    compr_liquido = parse_be16(pct[4:6])
    compr_payload = compr_liquido - 2
    cmd = parse_be16(pct[6:8])
    payload = pct[8:8+compr_payload]
    return cmd, payload

# Cria um pacote de autenticação para o protocolo de fotos
def pacote_foto_auth(senha, tam_senha):
    # 0x02 software de monitoramento, 0x03 mobile app
    sw_type = [ 0x02 ]
    senha = contact_id_encode(senha, tam_senha)
    sw_ver = [ 0x10 ]  # nibble.nibble (0x10 = 1.0)
    payload = sw_type + senha + sw_ver
    return pacote_foto(0xf0f0, payload)

# Cria um pacote de requisição de fragmento de foto
def pacote_foto_req(indice, foto, fragmento):
    payload = be16(indice) + [ foto, fragmento ]
    return pacote_foto(0x0bb0, payload)

# Cria um pacote de desconexão
def pacote_foto_bye():
    return pacote_foto(0xf0f1, [])

eventos_contact_id = {
        100: {'*': "Emergencia medica"},
        110: {'*': "Alarme de incendio"},
        120: {'*': "Panico"},
        121: {'*': "Ativacao/desativacao sob coacao"},
        122: {'*': "Panico silencioso"},
        130: {
            'aber': "Disparo de zona {zona}",
            'rest': "Restauracao de zona {zona}"
             },
        133: {'*': "Disparo de zona 24h {zona}"},
        146: {'*': "Disparo silencioso {zona}"},
        301: {
            'aber': "Falta de energia AC",
            'rest': "Retorno de energia AC"
             },
        342: {
             'aber': "Falta de energia AC em componente sem fio {zona}",
             'rest': "Retorno energia AC em componente sem fio {zona}"
             },
        302: {
            'aber': "Bateria do sistema baixa",
            'rest': "Recuperacao bateria do sistema baixa"
             },
        305: {'*': "Reset do sistema"},
        306: {'*': "Alteracao programacao"},
        311: {
            'aber': "Bateria ausente",
            'rest': "Recuperacao bateria ausente"
             },
        351: {
            'aber': "Corte linha telefonica",
            'rest': "Restauro linha telefonica"
             },
        354: {'*': "Falha ao comunicar evento"},
        147: {
            'aber': "Falha de supervisao {zona}",
            'rest': "Recuperacao falha de supervisao {zona}"
             },
        145: {
             'aber': "Tamper em dispositivo expansor {zona}",
             'rest': "Restauro tamper em dispositivo expansor {zona}"
              },
        383: {
              'aber': "Tamper em sensor {zona}",
              'rest': "Restauro tamper em sensor {zona}"
              },
        384: {
            'aber': "Bateria baixa em componente sem fio {zona}",
            'rest': "Recuperacao bateria baixa em componente sem fio {zona}"
             },
        401: {
             'rest': "Ativacao manual",
             'aber': "Desativacao manual"
             },
        403: {
             'rest': "Ativacao automatica",
             'aber': "Desativacao automatica"
             },
        404: {
            'rest': "Ativacao remota",
            'aber': "Desativacao remota",
             },
        407: {
            'rest': "Ativacao remota II",
            'aber': "Desativacao remota II",
             },
        408: {'*': "Ativacao por uma tecla"},
        410: {'*': "Acesso remoto"},
        461: {'*': "Senha incorreta"},
        570: {
             'aber': "Bypass de zona {zona}",
             'rest': "Cancel bypass de zona {zona}"
             },
        602: {'*': "Teste periodico"},
        621: {'*': "Reset do buffer de eventos"},
        601: {'*': "Teste manual"},
        616: {'*': "Solicitacao de manutencao"},
        422: {
            'aber': "Acionamento de PGM {zona}",
            'rest': "Desligamento de PGM {zona}"
             },
        625: {'*': "Data e hora reiniciados"}
}


# Agente que obtem fotos de um evento de sensor com câmera

class ObtemFotosDeEvento(TCPClientHandler):
    def __init__(self, ip_addr, cport, indice, nrfoto, senha, tam_senha, observer):
        super().__init__((ip_addr, cport))
        self.log_info("Iniciando obtencao de foto %d:%d" % (indice, nrfoto))
        self.conn_timeout = self.timeout("conn_timeout", 15, self.conn_timeout)
        self.ip_addr = ip_addr
        self.cport = cport
        self.indice = indice
        self.nrfoto = nrfoto
        self.senha = senha
        self.tam_senha = tam_senha
        self.observer = observer

        # Se destruído com esse status, reporta erro fatal
        self.status = 2

        self.tratador = None

    def destroyed_callback(self):
        # Informa observador sobre status final da tarefa
        self.observer.resultado_foto(self.ip_addr, self.cport, \
                                     self.indice, self.nrfoto, \
                                     self.status)

    def conn_timeout(self, task):
        if self.status != 0:
            # reporta erro não-fatal, exceto se status = 0 (download completo)
            self.status = 1
        self.log_info("Timeout conexao foto")
        self.destroy()

    def connection_callback(self, ok):
        self.conn_timeout.cancel()
        if not ok:
            self.status = 1 # erro não-fatal
            self.log_info("Conexao foto falhou")
            # destroy() executado pelo chamador
            return
        self.autenticacao()

    def autenticacao(self):
        self.log_debug("Conexao foto: auth")
        pct = pacote_foto_auth(self.senha, self.tam_senha)
        self.send(pct)

        self.tratador = self.resposta_autenticacao
        self.conn_timeout.restart()

    def resposta_autenticacao(self, cmd, payload):
        if cmd == 0xf0fd:
            self.nak(payload)
            return

        if cmd != 0xf0f0:
            self.log_info("Conexao foto: resp inesperada %04x" % cmd)
            self.destroy()
            return

        if len(payload) != 1:
            self.log_info("Conexao foto: resp auth invalida")
            self.destroy()
            return

        resposta = payload[0]
        if resposta > 0:
            self.log_info("Conexao foto: auth falhou motivo %d" % resposta)
            self.destroy()
            return

        self.log_info("Conexao foto: autenticado")
        self.inicia_obtencao_fotos()

    def inicia_obtencao_fotos(self):
        # Fragmento 1 sempre existe
        self.obtem_fragmento_foto(1, [])

    def obtem_fragmento_foto(self, fragmento_corrente, jpeg_corrente):
        self.log_debug("Conexao foto: obtendo fragmento %d" % fragmento_corrente)
        pct = pacote_foto_req(self.indice, self.nrfoto, fragmento_corrente)
        self.send(pct)

        def tratador(cmd, payload):
            self.resposta_fragmento(cmd, payload, fragmento_corrente, jpeg_corrente)

        self.tratador = tratador
        self.conn_timeout.restart()

    def resposta_fragmento(self, cmd, payload, fragmento_corrente, jpeg_corrente):
        if cmd == 0xf0fd:
            self.nak(payload)
            return

        if cmd == 0xf0f7:
            # Código não documentado retornado pela central após lentidão
            # Possivelmente sinaliza central ocupada
            self.status = 1 # erro não-fatal
            self.destroy()
            return

        if cmd != 0x0bb0:
            self.log_info("Conexao foto: resp inesperada %04x" % cmd)
            self.destroy()
            return

        if len(payload) < 6:
            self.log_info("Conexao foto: resp frag muito curta")
            self.destroy()
            return

        self.log_debug("Conexao foto: resposta fragmento %d" % fragmento_corrente)

        indice = parse_be16(payload[0:2])
        foto = payload[2]
        nr_fotos = payload[3]
        fragmento = payload[4]
        nr_fragmentos = payload[5]
        fragmento_jpeg = payload[6:]

        if indice != self.indice:
            self.log_info("Conexao foto: indice invalido")
            self.destroy()
            return

        if foto != self.nrfoto:
            self.log_info("Conexao foto: nr foto invalida")
            self.destroy()
            return

        if fragmento != fragmento_corrente:
            self.log_info("Conexao foto: frag corrente invalido")
            self.destroy()
            return

        jpeg_corrente += fragmento_jpeg

        if fragmento < nr_fragmentos:
            self.obtem_fragmento_foto(fragmento + 1, jpeg_corrente)
            return

        self.log_info("Conexao foto: salvando imagem")
        f = open("imagem%.6f.jpeg" % time.time(), "wb")
        f.write(bytearray(jpeg_corrente))
        f.close()

        self.despedida()

    def despedida(self):
        self.log_debug("Conexao foto: despedindo")
        pct = pacote_foto_bye()
        self.send(pct)

        self.tratador = None
        # Reportar sucesso ao observador
        self.status = 0
        self.conn_timeout.restart()
        # Resposta esperada: central fechar conexão

    def nak(self, payload):
        if len(payload) != 1:
            self.log_info("Conexao foto: NAK invalido")
        else:
            motivo = payload[0]
            self.log_info("Conexao foto: NAK motivo %02x" % motivo)
            self.status = 1 # erro não-fatal
        self.destroy()

    def recv_callback(self, latest):
        self.log_debug("Conexao foto: recv", latest)

        compr = pacote_foto_completo(self.recv_buf)
        if not compr:
            self.log_debug("Conexao foto: incompleto")
            return

        pct, self.recv_buf = self.recv_buf[:compr], self.recv_buf[compr:]

        if not pacote_foto_correto(pct):
            self.log_info("Conexao foto: pacote incorreto, desistindo")
            self.destroy()
            return

        cmd, payload = pacote_foto_parse(pct)
        self.log_debug("Conexao foto: resposta %04x" % cmd)

        if not self.tratador:
            self.log_info("Conexao foto: sem tratador")
            self.destroy()
            return

        self.conn_timeout.cancel()
        self.tratador(cmd, payload)


class Tratador(TCPServerHandler):
    backoff_minimo = 0.125
    recuo_backoff_minimo = 1.0 # Deve ser bem maior que RTT esperado

    def __init__(self, addr, sock):
        super().__init__(addr, sock)

        self.log_info("inicio")
        self.backoff = Tratador.backoff_minimo

        self.to_ident = self.timeout("ident", 120, self.timeout_identificacao)
        self.to_comm = self.timeout("comm", 600, self.timeout_comunicacao)
        to_hb = self.timeout("hb", 3600, self.heartbeat)
        self.to_processa = None
        self.to_incompleta = None
        self.to_backoff = None

        self.ip_addr = addr[0]

    def heartbeat(self, to_obj):
        self.log_info("permanece conectado")
        to_obj.restart()

    def timeout_comunicacao(self, _):
        self.log_info("timeout de comunicacao")
        self.destroy()

    def timeout_msgincompleta(self, _):
        self.log_warn("timeout de mensagem incompleta, buf =", hexprint(self.recv_buf))
        self.destroy()

    def timeout_identificacao(self, _):
        self.log_warn("timeout de identificacao")
        self.destroy()

    def _envia(self, resposta):
        self.send(bytearray(resposta))
        self.log_debug("enviada resposta", hexprint(resposta))

    def envia_longo(self, resposta):
        resposta = enquadrar(resposta)
        self._envia(resposta)

    def envia_curto(self, resposta):
        self._envia(resposta)

    def recv_callback(self, _):
        self.log_debug("evento")
        self.log_debug("buf =", hexprint(self.recv_buf))
        self.to_comm.restart()
        if not self.to_processa:
            self.to_processa = self.timeout("proc_msg", self.backoff, self.processar_msg)

    def shutdown_callback(self):
        self.log_info("fechada")
        super().shutdown_callback() # impl padrão = fechar

    def send_callback(self):
        self.log_debug("envio dados")
        super().send_callback()

    def processar_msg(self, _):
        self.to_processa = None
        msg_aceita, msgs_pendentes = self.consome_msg()
        if msg_aceita:
            self.avancar_backoff()
        if msgs_pendentes:
            self.to_processa = self.timeout("proc_msg", self.backoff, self.processar_msg)

    def consome_msg(self):
        if self.consome_frame_curto() or self.consome_frame_longo():
            # Processou uma mensagem
            if self.to_incompleta:
                self.to_incompleta.cancel()
                self.to_incompleta = None
            return True, not not self.recv_buf

        if self.recv_buf:
            # Mensagem incompleta no buffer
            if not self.to_incompleta:
                self.to_incompleta = self.timeout("msgincompleta", 60, self.timeout_msgincompleta)
        return False, False

    def avancar_backoff(self):
        self.backoff *= 2 # Backoff exponencial
        self.log_debug("backoff aumentado para %f" % self.backoff)

        if self.to_backoff:
            self.to_backoff.cancel()
            self.to_backoff = None

        self.to_backoff = self.timeout("recuar_backoff",
            max(Tratador.recuo_backoff_minimo, self.backoff * 2),
            self.recuar_backoff)

    def recuar_backoff(self, _):
        self.to_backoff = None

        self.backoff /= 2
        self.backoff = max(self.backoff, Tratador.backoff_minimo)
        self.log_debug("backoff reduzido para %f" % self.backoff)

        if self.backoff > Tratador.backoff_minimo:
            self.to_backoff = self.timeout("recuar_backoff",
                max(Tratador.recuo_backoff_minimo, self.backoff * 2),
                self.recuar_backoff)

    def consome_frame_curto(self):
        if self.recv_buf and self.recv_buf[0] == 0xf7:
            self.recv_buf = self.recv_buf[1:]
            self.log_debug("heartbeat da central")
            resposta = [0xfe]
            self.envia_curto(resposta)
            return True
        return False

    def consome_frame_longo(self):
        if len(self.recv_buf) < 2:
            return False

        esperado = self.recv_buf[0] + 2 # comprimento + dados + checksum
        if len(self.recv_buf) < esperado:
            return False

        rawmsg = self.recv_buf[:esperado]
        self.recv_buf = self.recv_buf[esperado:]

        if not verificar(rawmsg):
            self.log_warn("checksum errado, rawmsg =", hexprint(rawmsg))
            return True

        # Mantém checksum no final pois, em algumas mensagens, o último octeto
        # calcula como checksum mas tem outro significado (e.g. 0xb5)
        msg = rawmsg[1:]

        if not msg:
            self.log_warn("mensagem nula")
            return True

        tipo = msg[0]
        msg = msg[1:]

        if tipo == 0x80:
            self.solicita_data_hora(msg)
        elif tipo == 0x94:
            self.identificacao_central(msg)
        elif tipo == 0xb0:
            self.evento_alarme(msg, False)
        elif tipo == 0xb5:
            self.evento_alarme(msg, True)
        else:
            self.log_warn("solicitacao desconhecida %02x payload =" % tipo, hexprint(msg))
            self.resposta_generica(msg)
        return True

    def resposta_generica(self, msg):
        resposta = [0xfe]
        self.envia_curto(resposta)

    # TODO verificar se a central é a esperada
    def identificacao_central(self, msg):
        if len(msg) != 7:
            self.log_warn("identificacao central: tamanho inesperado,", hexprint(msg))
        else:
            canal = msg[0] # 'E' (0x45)=Ethernet, 'G'=GPRS, 'H'=GPRS2
            conta = from_bcd(msg[1:3])
            macaddr = msg[3:6]
            macaddr_s = ":".join(["%02x" % i for i in macaddr])
            self.log_info("identificacao central conta %d mac %s" % (conta, macaddr_s))
            if self.to_ident:
                self.to_ident.cancel()
                self.to_ident = None

        resposta = [0xfe]
        self.envia_curto(resposta)

    def solicita_data_hora(self, msg):
        self.log_debug("solicitacao de data/hora pela central")
        agora = datetime.datetime.now()
        # proto: 0 = domingo; weekday(): 0 = segunda
        dow = (agora.weekday() + 1) % 7
        resposta = [ 0x80, bcd(agora.year - 2000), bcd(agora.month), bcd(agora.day), \
            bcd(dow), bcd(agora.hour), bcd(agora.minute), bcd(agora.second) ]
        self.envia_longo(resposta)

    def evento_alarme(self, msg, com_foto):
        compr = com_foto and 20 or 17
        if len(msg) != compr:
            self.log_warn("evento de alarme de tamanho inesperado,", hexprint(msg))
            resposta = [0xfe]
            self.envia_curto(resposta)
            return

        canal = msg[0] # 0x11 Ethernet IP1, 0x12 IP2, 0x21 GPRS IP1, 0x22 IP2
        contact_id = contact_id_decode(msg[1:5])
        tipo_msg = contact_id_decode(msg[5:7]) # 18 decimal = Contact ID
        qualificador = msg[7]
        codigo = contact_id_decode(msg[8:11])
        particao = contact_id_decode(msg[11:13])
        zona = contact_id_decode(msg[13:16])
        if com_foto:
            checksum = msg[16] # truque do protocolo de reposicionar o checksum
            indice = msg[17] * 256 + msg[18]
            nr_fotos = msg[19]

        desconhecido = True
        if tipo_msg == 18 and codigo in eventos_contact_id:
            if qualificador == 1:
                squalif = "aber"
                if squalif not in eventos_contact_id[codigo]:
                    squalif = "*"
            elif qualificador == 3:
                squalif = "rest"
                if squalif not in eventos_contact_id[codigo]:
                    squalif = "*"
            else:
                squalif = "*"

            if squalif in eventos_contact_id[codigo]:
                desconhecido = False
                scodigo = eventos_contact_id[codigo][squalif]
                fotos = ""
                if com_foto:
                    fotos = "fotos: %d %d" % (indice, nr_fotos)
                self.log_info(scodigo.format(zona=zona, particao=particao), fotos)

                if com_foto:
                    for n in range(0, nr_fotos):
                        Tratador.tratador_de_fotos.enfileirar(self.ip_addr, indice, n)

        if desconhecido:
            self.log_info("Evento de alarme canal %02x contact_id %d tipo %d qualificador %d "
                          "codigo %d particao %d zona %d" % \
                          (canal, contact_id, tipo_msg, qualificador, codigo, particao, zona))

        resposta = [0xfe]
        self.envia_curto(resposta)


# Tratador de fotos obtidas via eventos 0xb5. Desacoplado do tratador 
# principal pois usa conexões separadas, e as fotos ficam armazenadas
# por tempo indeterminado na central, não sendo atreladas à conexão com
# o Receptor IP.
#
# Numa implementação futura os índices das fotos poderiam ser até
# armazenados num banco de dados local, para que não se percam quando
# o programa é reiniciado.

class TratadorDeFotos:
    def __init__(self, cport, senha, tam_senha):
        self.cport = cport
        self.senha = senha
        self.tam_senha = tam_senha
        self.fila = [] # [endereço IP, indice, nr. foto, tentativas restantes]
        self.task = None

    # Recebe nova foto de algum Tratador para a fila
    def enfileirar(self, ip_addr, indice, nrfoto):
        self.fila.append([ip_addr, indice, nrfoto, 10])
        if not self.task:
            # Fotos de sensor 8000 demoram para gravar (NAK 0x28 = foto não gravada)
            self.task = Timeout.new("trata_foto", 20, self.obtem_foto)

    def obtem_foto(self, task):
        if not self.fila:
            self.task = None
            return

        ip_addr, indice, nrfoto, tentativas = self.fila[0]
        Log.info("tratador de fotos: obtendo %s:%d:%d tentativas %d" % \
                      (ip_addr, indice, nrfoto, tentativas))

        ObtemFotosDeEvento(ip_addr, self.cport, indice, nrfoto, \
                            self.senha, self.tam_senha, self)

    # observer chamado quando ObtemFotosDeEvento finaliza
    def resultado_foto(self, ip_addr, cport, indice, nrfoto, status):
        if status == 0:
            Log.info("Fotos indice %s:%d:%d: sucesso" % (ip_addr, indice, nrfoto))
            self.fila[0][3] = 0
        elif status == 2:
            Log.info("Fotos indice %s:%d:%d: erro fatal" % (ip_addr, indice, nrfoto))
            self.fila[0][3] = 0
        else:
            Log.info("Fotos indice %s:%d:%d: erro temporario" % (ip_addr, indice, nrfoto))
            self.fila[0][3] -= 1

        if self.fila[0][3] <= 0:
            del self.fila[0]

        self.task.restart()


def heartbeat(to_obj):
    Log.info("receptor em funcionamento")
    to_obj.reset(3600)

Timeout.new("heartbeat", 0, heartbeat)

host = "0.0.0.0"
port = int(sys.argv[1]) or 9009  # Porta deste Receptor IP
cport = int(sys.argv[2]) or 9009 # Porta da central de alarme
senha = int(sys.argv[3])         # Senha de acesso remoto (usuário 98)
tam_senha = int(sys.argv[4])     # Tamanho da senha (4 ou 6 dígitos)

Tratador.tratador_de_fotos = TratadorDeFotos(cport, senha, tam_senha)

TCPServerEventLoop((host, port), TCPListener, Tratador).loop()
